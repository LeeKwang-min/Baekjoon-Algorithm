/*
작성자 : 이광민
일시 : 2021.06.25
제목 : 17069 - 파이프 옮기기 2
풀이 : 파이프 옮기기 1과 달리 주어지는 배열의 범위가 최대 32 X 32까지 올라가서 브루트 포스로는 풀기가 힘들다.
       동적 프로그래밍을 사용해야 한다.

	   DP[N][M][3] = N, M에 0가로/1세로/2대각선 파이프가 붙을 수 있는 갯수
	   문제에서 주어지는 붙을 수 있는 경우를 살펴보면
	   가로 -> 이 전의 파이프가 가로나 대각선
	   세로 -> 이 전의 파이프가 세로나 대각선
	   대각선 -> 이 전의 파이프가 가로, 세로, 대각선

	   이 경우이기 때문에 각각의 경우에 대해 해당 값들을 더해주면 된다.
	   [0] = [0] + [2]
	   [1] = [1] + [2]
	   [2] = [0] + [1] + [2]

	   처음에 반복문의 범위를 n을 제외하고 < n까지를 확인했으나 이는 잘못된 생각.

	   [i][j + 1] 혹은 [i + 1][j]의 경우 n까지 반복문을 돌아야 [n][n]을 처리하게 된다.
	   범위를 벗어나는 값에 대해서는 조건문을 통해 예외처리 해주면 된다.

	   모든 값을 구하고 최종적인 정답은 
	   [0] + [1] + [2]가 된다.
*/
#include<iostream>

using namespace std;

int n;
int arr[33][33];
long long d[33][33][3]; 

int main() {
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	cin >> n;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			cin >> arr[i][j];

	d[1][2][0] = 1; 
	for (int i = 1; i <= n; i++) {
		for (int j = 2; j <= n; j++) {
			if (j + 1 < n + 1)
				if (arr[i][j + 1] == 0) d[i][j + 1][0] = d[i][j][0] + d[i][j][2];
			if (i + 1 < n + 1)
				if (arr[i + 1][j] == 0) d[i + 1][j][1] = d[i][j][1] + d[i][j][2];
			if (i < n + 1 && j < n + 1)
				if (arr[i + 1][j] == 0 && arr[i][j + 1] == 0 && arr[i + 1][j + 1] == 0)
					d[i + 1][j + 1][2] = d[i][j][0] + d[i][j][1] + d[i][j][2];
		}
	}
	cout << d[n][n][0] + d[n][n][1] + d[n][n][2];
}