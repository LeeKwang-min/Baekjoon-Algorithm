'''
풀이의 핵심 키포인트는
특정 코인들을 사용하여 1 ~ n원을 만들 수 있다면
새로운 코인 m짜리가 생기게 된다면
1+m ~ n+m원을 마찬가지로 만들 수 있다는 것에서 시작한다.

우선 주어진 동전들은 오름차순으로 정렬해주고 가장 먼저 1원을 만들수 있는지를 확인한다. (자연수 중 최솟값을 찾아야 하기 때문에)
1원을 만들 수 있다면 현재 1원까지는 무조건 만들 수 있다는 조건이 깔리고
다음 동전을 확인해서 현재 만들 수 있는 값에 새로운 동전이 추가된다면 또 어디까지 만들 수 있는지 확인하면 된다.

여기서 한가지 분기점이 생기고 정답을 도출할 수 있게 되는데
바로 새로운 동전이 현재 내가 확인하는 최솟값보다 큰 경우이다.

예를 들어 1 ~ 5까지의 수를 만들 수 있을 때 새로운 동전으로 7이 들어오게 된다면 
7 ~ 12까지는 수를 만들 수 있지만 기존에 존재하던 1 ~ 5 그리고 7 ~ 12가 가능하기 때문에 정답은 불가능한 6이 된다.

그렇기 때문에 현재 확인하고 있는 answer의 값을 잘 변화 시키는것이 핵심이 된다.

현재 확인하는 값이 새로운 동전보다 작은 수라면 해당 값이 정답이 된다.
'''
n = int(input())
coin = list(map(int, input().split()))

coin.sort()

answer = 1
for c in coin:
    if answer < c:
        break
    answer += c
    
print(answer)

'''
5
3 2 1 1 9

// 8
'''