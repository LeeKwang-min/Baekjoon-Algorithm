'''
카카오 문제... 참 어렵다 (4레벨)

우선 우선순위 큐를 사용하여 문제를 처리한다는 점을 알아두자

풀이의 핵심은 다음과 같다.
우선순위 큐에서 가장 적게 시간이 드는 음식을 확인하여 해당 음식을 모두 먹는데 걸리는 시간을 확인한다.
예를 들어 에러가 발생하는 시간이 15초이고 총 3개의 음식에서 가장 적게 시간이 드는 음식이 4라면
가장 작은 음식을 모두 먹는데 걸리는 시간은 12초로 15초 안에 모두 먹게 된다.
해당 음식을 모두 먹고 나서는 남은 음식 즉 2개의 음식을 가지고 남은 시간안에 먹을 수 있는지를 확인한다.

예를 들어 8, 6, 4 3가지 음식과 15초라는 k가 주어졌을 때 
앞서 말한것과 같이 4 음식을 모두 먹는데 12초가 걸리고 나면 
1. k는 3초가 남는다.
2. 8과 6 음식은 4와 2가 남게된다.
3. 4와 2에서 2를 모두 먹는데 걸리는 시간은 2개의 음식 * 2 = 4로 4초가 걸린다.
4. 남은 시간은 3초 먹는데 걸리는 시간은 4초로 모두 회전하지 못한다.
5. 남은 음식들을 순차적으로 먹을 때 어떤 음식이 k초 뒤에 내 앞에 오는지를 계산하면 된다.
위 과정을 밟으며 값을 처리하면 된다.

<놓친 부분>
1. 가장 적은 음식을 먹는 동안 나머지 음식들의 양도 줄어든다.
2. 마지막 q에 담긴 음식들의 순서는 'lambda를 사용하여 정렬을 하여도 1, 2, 3, ... 의 순서가 아니다' (1, 3, 5 일수도 있고 3, 5, 10 일수도 있다.)
3. 튜플 리스트에서 두번째 인자로 정렬하는 방법은 'lambda x: x[1]'과 같이 사용한다.
'''
import heapq

def solution(food_times, k):
    if sum(food_times) <= k:
        return -1
    
    answer = 0
    
    q = []
    
    for i in range(len(food_times)):
        heapq.heappush(q, (food_times[i], i))
        
    sum_value = 0 # 총 몇번 먹었는지 확인용

    while (len(q) * (q[0][0] - sum_value)) < k:
        k -= len(q) * (q[0][0] - sum_value)
        sum_value = q[0][0]
        heapq.heappop(q)
    
    q.sort(key= lambda x : x[1])
    
    answer = q[k % len(q)][1] + 1
    
    return answer

print(solution([3, 1, 2], 5)) # 1
print(solution([8, 6, 4], 15)) # 2